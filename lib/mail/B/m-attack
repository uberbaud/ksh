#!/bin/ksh
# <@(#)tag:tw.csongor.uberbaud.foo,2024-07-23,03.07.26z/5cf85d8>
# vim: ft=ksh ts=4 tw=72 noexpandtab nowrap foldmethod=marker

set -o nounset;: ${FPATH:?Run from within KSH}

CONTMSG='Press any key to continue.'
DEFAULT_FLDR=inbox
DEFAULT_SEQ='¬L'	# NOT messages in groups
fERRs=.attack.out

# Usage {{{1
this_pgm=${0##*/}
function usage {
	desparkle "$this_pgm"
	PGM=$REPLY
	sparkle >&2 <<-\
	===SPARKLE===
	^F{4}Usage^f: ^T$PGM^t
	         A CLI to process mail, cycling through all +^O$^o^VMBOX^v ^VSEQ^v messages
	         ^GNote:^g ^VMBOX^v ^Gdefaults to^g ^Tinbox^t^G, and^g
	               ^VSEQ^v ^Gdefaults to^g ^O¬^o^TL^t^G, or^g ^Ta^t ^Gif^g ^VMBOX^v ^Gis specified.^g
	       ^T$PGM -h^t
	         Show this help message.
	===SPARKLE===
	exit 0
} # }}}
# process -options {{{1
while [[ ${1:-} == -* ]]; do
	case ${1#-} in
		-)	shift; break;										;;
		h)	usage;												;;
		*)	die USAGE "Invalid option: ^T$1^t.";				;;
	esac
	shift
done
# remove already processed arguments
shift $((OPTIND-1))
# ready to process non '-' prefixed arguments
# /options }}}1
function pause-for-key { forceline; press-any-key "$CONTMSG"; }
function pause-warn { warn "$@"; print -n '     '; pause-for-key; }
function revert-cursor-pos { ((${1:?}))&& print -n -- '\033['"$1"'A\033[J'; }
function set-curmsg { # {{{1
	local rc
	CUR_MSG_NUM=$(pick +$FLDR MSGs:${1:?} -sequence c -list) 2>$fERRs.1
	rc=$?; (($rc == 0 || $rc == 64))|| warn "$(<$fERRs)"
	return $rc
} # }}}1
function msg-prev { set-curmsg p; }
function msg-next { set-curmsg n; }
function msg-show { show +$FLDR ${1:?}; print -n '\033[A'; }
function msg-webview { LOGLEVEL=0 m-part "${1:?}"; }
function msg-xplode { mhstore +$FLDR ${1:?}; }
function msg-open-urls { # {{{1
	local u
	[[ -n ${BROWSER:=$(<${XDG_CONFIG_HOME:?}/etc/browser)} ]]||
		pause-warn '^O$^o^VBROWSER^v is not set.'

	set -- $(show +$FLDR "$@" | egrep -o 'https?://[^[:space:]]+')
	$BROWSER "$@" || for u { print -r -- "$u"; pause-warn 'Browser issue.'; }
} # }}}1
function set-actlist { # {{{1
	local first rest action list
	for action; do
		rest=${action#?}
		first=${action%"$rest"}
		list="${list:+$list }^U^O$first^o$rest^u"
	done
	print -r -- "$list."
} # }}}1
function show-msg-info { # {{{1
	scan +$FLDR -width 9999 -format scan.borders ${1:?} ||
		warn "scan +$FLDR -width 9999 -format scan.borders ${1:?}"
	print
	notify "${ACTLIST:=$(
		set-actlist prev next show webview 'open urls' xplode quit
	  )}"
	getkey pnNswoxq
	case $REPLY in
		p)	REPLY=prev;			;;
		n)	REPLY=next;			;;
		N)	REPLY=prev;			;; # undocumented but often used
		s)	REPLY=show;			;;
		w)	REPLY=webview;		;;
		o)	REPLY=open-urls;	;;
		x)	REPLY=xplode;		;;
		q)	REPLY=quit;			;;
		*)	bad-programmer "Unhandled action key ^B$REPLY%b.";	;;
	esac
} # }}}1
function main { # {{{1
	mark +$FLDR "$@" -sequence MSGs 2>$fERRs.1 || {
		#if [[ $(<$fERRs.1} == 
		#	die "No messages in ^V$FLDR^v^:^V$*^v."
		#else
			die "Bad pick options." "+$FLDR" "$@"
		#fi
	  }

	# save c in case we're doing other things elsewhere
	typeset -i CUR_MSG_NUM=$(pick +$FLDR c 2>/dev/null)
	((CUR_MSG_NUM))||
		CUR_MSG_NUM=$(pick +$FLDR MSGs:f -sequence c -list 2>/dev/null)

	integer xtrarows=0
	while :; do
		revert-cursor-pos $xtrarows
		show-msg-info $CUR_MSG_NUM
		case $REPLY in
			quit)		break;							;;
			prev|next|show)
				msg-$REPLY $CUR_MSG_NUM || break
				xtrarows=0
				;;
			*)
				msg-$REPLY $CUR_MSG_NUM 2>&1			|
					fold -sw ${COLUMNS:=$(tput cols)}	|
					tee $fERRs
				xtrarows=$(wc -l <$fERRs)
				((xtrarows>0))&& pause-for-key $((xtrarows++))
				rm -f $fERRs
				;;
		esac
		((xtrarows+=5)) # Add the height used by show-msg-info
	done

	mark +$FLDR -sequence MSGs -delete a
} # }}}1

needs use-app-paths 
use-app-paths mail || die '^Buse-app-paths^b ^Vmail^v'
needs egrep fold forceline m-part mhstore pick press-any-key scan show tee mark

[[ $* == ?*+* ]]&&
	die "Bad parameter list, mailbox other than first."

if [[ $# -gt 0 && $1 == +* ]]; then
	FLDR=${1#+}; shift
	(($#))|| set -- a
elif (($#)); then
	FLDR=$DEFAULT_FLDR
else
	FLDR=$DEFAULT_FLDR
	if pick +$FLDR $DEFAULT_SEQ:f >/dev/null 2>&1; then
		set -- "$DEFAULT_SEQ"
	else
		set -- a
	fi
fi

main "$@"; exit

# Copyright (C) 2024 by Tom Davis <tom@greyshirt.net>.
