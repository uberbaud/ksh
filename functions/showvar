# <@(#)tag:csongor.greyshirt.net,2018-02-08:tw/20.12.04z/1b4f09d>
# vim: filetype=ksh tabstop=4 textwidth=72 noexpandtab nowrap

#: FUNCTION ^Uvarname^u
#:   Shows information about ^Uvarname^u.

showvar() {
	set -- "$@" "$?" "$-" "$_" # save special variables
	(($#!=4))&& die 'Expected exactly one (1) variable name.'
	( # use a subshell so we can alter variables (REPLY)
	case "$1" in
		\@|\*|\#|[1-9])
			die 'Cannot access parent argument list.';	;;
		\_)
			sparkle <<-==SPARKLE==
			  ^B$1^b is a ^Bspecial^b variable whose value is
			    1. the last word of previous command,
			    2. the path of the executed command, or
			    3. the name of the file in ^SMAILPATH^s that changed.
			==SPARKLE==
			return
			;;
		@(\?|-|!|$|0))
			case $1 in
				\?)	set -- "$1" "$2";					;;
				-)	set -- "$1" "$3";					;;
				!)	set -- "$1" "$!";					;;
				$)	set -- "$1" "$$";					;;
				0)	set -- "$1" "$0";					;;
				_)	set -- "$1" "$4";					;;
				*) die 'Bad programmer (2nd case).';	;;
			esac
			sparkle <<-==SPARKLE==
			  ^B$1^b is a ^Bspecial^b variable with a value of:
			    $2
			==SPARKLE==
			return
			;;
		PWD)
			desparkle "$PWD"
			sparkle <<-==SPARKLE==
			  ^BPWD^b is a ^Bspecial^b variable whose value is set to
			    the working directory by the shell. Current value is
			      $REPLY
			==SPARKLE==
			return
			;;
		RANDOM)
			sparkle <<-==SPARKLE==
			  ^BRANDOM^b is a ^Bspecial^b variable whose value is
			    randomly generated (e.g. ^S$RANDOM^s).
			==SPARKLE==
			return
			;;
		REPLY)
			local x attr="scalar"
			x="$(typeset|egrep " $1\$")"
			[[ -n $x ]]|| die 'Variable is not set'
			[[ $x == *'-i'* ]]&& attr="integer"
			[[ $x == *'-U'* ]]&& attr="unsigned integer"
			[[ $x == *'-L'* ]]&& {
				x="${x#*-L}"; x="${x%% *}"
				attr="left justified to $x bytes $attr"
			  }
			[[ $x == *'-R'* ]]&& {
				x="${x#*-R}"; x="${x%% *}"
				attr="right justified to $x bytes $attr"
			  }
			[[ $x == *'-Z'* ]]&& attr="zero filled $attr"
			[[ $x == *'-l'* ]]&& attr="lowercase $attr"
			[[ $x == *'-u'* ]]&& attr="uppercase $attr"
			[[ $x == *'-r'* ]]&& attr="readonly $attr"
			[[ $x == *'-x'* ]]&& attr="exported $attr"
			set -- $(typeset +|egrep "^$1(\[[0-9]+\])?$")
			print -n -- "  \033[1mREPLY\033[22m is "
			if [[ $1 == *\] ]]; then
				print "an \033[1marray\033[22m of $attr, with \033[1m$#\033[22m slots."
			else
				if [[ $attr == [aeiou]* ]]; then
					print -n "an "
				else
					print -n "a "
				fi
				print "$attr with a value of:"
			fi
			for x; do
				if [[ $x == *\] ]]; then
					set -- "$x"
					x="${x#*\[}"
					x="${x%\]}"
					printf "%4s: " "$x"
					x="$1"
				else
					print -n '    '
				fi
				eval "x=\"\${$x}\""
				qvis "$x"
			done
			return 0
			;;
	esac
	[[ $1 == [A-Za-z_]*([A-Za-z0-9_]) ]]|| {
		desparkle "$1"
		die "^B$REPLY^b does not look like a variable name."
	  }
	# get info about the variable first!
	set -- "$1" scalar
	REPLY="$(typeset|egrep " $1\$")"
	# if it doesn't exist, we can exit
	[[ -n $REPLY ]]|| die 'Variable is not set'
	[[ $REPLY == *'-i'* ]]&& set -- "$1" "integer"
	[[ $REPLY == *'-U'* ]]&& set -- "$1" "unsigned integer"
	[[ $REPLY == *'-L'* ]]&& {
		set -- "$1" "$2" "$REPLY"
		REPLY="${REPLY#*-L}"; REPLY="${REPLY%% *}"
		set -- "$1" "left justified to $REPLY bytes $2" "$3"
		REPLY="$3"
	  }
	[[ $REPLY == *'-R'* ]]&& {
		set -- "$1" "$2" "$REPLY"
		REPLY="${REPLY#*-R}"; REPLY="${REPLY%% *}"
		set -- "$1" "right justified to $REPLY bytes $2" "$3"
		REPLY="$3"
	  }
	[[ $REPLY == *'-Z'* ]]&& set -- "$1" "zero filled $2"
	[[ $REPLY == *'-l'* ]]&& set -- "$1" "lowercase $2"
	[[ $REPLY == *'-u'* ]]&& set -- "$1" "uppercase $2"
	[[ $REPLY == *'-r'* ]]&& set -- "$1" "readonly $2"
	[[ $REPLY == *'-x'* ]]&& set -- "$1" "exported $2"
	set -- "$1" "$2" $(typeset +|egrep "^$1(\[[0-9]+\])?$")
	print -n -- "  \033[1m$1\033[22m is " # 6 chars + len(varname)
	if [[ $3 == *\] ]]; then
		print "an \033[1marray\033[22m of $2, with \033[1m$(($#-2))\033[22m slots."
	else
		if [[ $2 == [aeiou]* ]]; then
			print -n "an "
		else
			print -n "a "
		fi
		(((${#1}+3+${#2}+17)>COLUMNS))&& print -n '\n    '
		if (((4+${#2}+17)>COLUMNS)); then
			print -- "$2\n    with a value of:"
		else
			print -- "$2 with a value of:"
		fi
	fi
	shift 2
	for REPLY; do
		if [[ $REPLY == *\] ]]; then
			set -- "$REPLY"
			REPLY="${REPLY#*\[}"
			REPLY="${REPLY%\]}"
			printf "%4s: " "$REPLY"
			REPLY="$1"
		else
			print -n '    '
		fi
		eval "REPLY=\"\${$REPLY}\""
		qvis "$REPLY"
	done
)}

# Copyright Â© 2018 by Tom Davis <tom@greyshirt.net>.
