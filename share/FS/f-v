# <@(#)tag:tw.csongor.greyshirt.net,2020-12-04,14.34.08z/3bbe5f3>
# vim: filetype=ksh tabstop=4 textwidth=72 noexpandtab

#: FUNCTION ^[^Uv.ksh_options^u^] ^[^Ufile_name^u^]
#:   Wrapper to allow alias processing.

needs find-function resolve-alias shquote
function f-v {
	local o opts i=0 cmdexp filexp edit ecmd xterm
	edit=$HOME/bin/ksh/v
	wait=wait-before-leaving
	set -A xterm -- nohup ${XTERM:-st} -e ksh -c

	# NO parameters, so short circuit all the others
	(($#))|| {
		(SHORTWAIT=1 "${xterm[@]}" "$wait $edit" &) >/dev/null 2>&1
		return
	}

	for o; do
		[[ $1 == -* ]]|| break
		opts[i++]=$1
		shift
	done

	(($#))|| { "$edit" "${opts[@]}" && return; }

	filexp=$1
	(($#))&& shift
	[[ $filexp == =* && ! -f $filexp ]]&& {
		filexp="${filexp#=}"
		cmdexp=$(command -v "$filexp") ||
			die "Could not resolve ^B$filexp^b."
		if [[ $cmdexp == alias\ * ]]; then
			filexp=$(resolve-alias "$filexp")
		else
			filexp=$cmdexp
		fi
		# If we're here, we've resolve a function or executabl, and
		# if it's an executable, we've been given the full path, so
		# if it doesn't start with '/', it's a function, so find the
		# path.
		[[ $filexp != /* ]]&&
			filexp=$(find-function "$filexp")
	  }
	set -- "$edit" "${opts[@]}" "$filexp" "$@"
	if [[ -n ${WINDOWID:-} ]]; then
		i=0
		ecmd[i++]=$wait
		for a { shquote "$a"; ecmd[i++]=$REPLY; }
		(SHORTWAIT=1 "${xterm[@]}" "${ecmd[*]}" &) >/dev/null 2>&1
	else
		"$@"
	fi
}

# Copyright Â© 2020 by Tom Davis <tom@greyshirt.net>.
